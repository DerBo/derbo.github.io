<!doctype html>
<html lang="en-us">
  <head>
    <title>数组排序算法   (二)直接排序 // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://derbo.gitub.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数组排序算法   (二)直接排序"/>
<meta name="twitter:description" content="对我以学知识的整理
我的GitHub:https://github.com/DerBo 原理：将一个数作为基准(默认选第一个元素)，用一个数据类型存储起来，通过将它后面的元素和保存的元素相比较，比它小(大)的和他交换位置，这样进行N-1次的遍历就可排好数组。 一 、代码
int[] arr = {49,38,65,97,76,13,27,49}; for(int i=1; i&lt;arr.length; i&#43;&#43;){//外循环的次数 = 轮数 = 数组的长度-1 //（1）找出本轮未排序元素中的最值 /* 未排序元素： 第1轮：i=1,未排序，[0,7] 第2轮：i=2,未排序，[1,7] ... 第7轮：i=7,未排序，[6,7] 每一轮未排序元素的起始下标：0,1,2,3,4,5,6，正好是i-1的 未排序的后面的元素依次： 第1轮：[1,7] j=1,2,3,4,5,6,7 第2轮：[2,4] j=2,3,4,5,6,7 。。。。 第7轮：[7] j=7 j的起点是i，终点都是7 */ int max = arr[i-1]; int index = i-1; for(int j=i; j&lt;arr.length; j&#43;&#43;){ if(arr[j] &gt; max){ max = arr[j]; index = j; } } //（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换 /* 第1轮，最大值应该在[0] 第2轮，最大值应该在[1] .... 第7轮，最大值应该在[6] 正好是i-1的值 */ if(index != i-1){ //交换arr[i-1]与arr[index] int temp = arr[i-1]; arr[i-1] = arr[index]; arr[index] = temp; } } //显示结果 for(int i=0; i&lt;arr."/>

    <meta property="og:title" content="数组排序算法   (二)直接排序" />
<meta property="og:description" content="对我以学知识的整理
我的GitHub:https://github.com/DerBo 原理：将一个数作为基准(默认选第一个元素)，用一个数据类型存储起来，通过将它后面的元素和保存的元素相比较，比它小(大)的和他交换位置，这样进行N-1次的遍历就可排好数组。 一 、代码
int[] arr = {49,38,65,97,76,13,27,49}; for(int i=1; i&lt;arr.length; i&#43;&#43;){//外循环的次数 = 轮数 = 数组的长度-1 //（1）找出本轮未排序元素中的最值 /* 未排序元素： 第1轮：i=1,未排序，[0,7] 第2轮：i=2,未排序，[1,7] ... 第7轮：i=7,未排序，[6,7] 每一轮未排序元素的起始下标：0,1,2,3,4,5,6，正好是i-1的 未排序的后面的元素依次： 第1轮：[1,7] j=1,2,3,4,5,6,7 第2轮：[2,4] j=2,3,4,5,6,7 。。。。 第7轮：[7] j=7 j的起点是i，终点都是7 */ int max = arr[i-1]; int index = i-1; for(int j=i; j&lt;arr.length; j&#43;&#43;){ if(arr[j] &gt; max){ max = arr[j]; index = j; } } //（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换 /* 第1轮，最大值应该在[0] 第2轮，最大值应该在[1] .... 第7轮，最大值应该在[6] 正好是i-1的值 */ if(index != i-1){ //交换arr[i-1]与arr[index] int temp = arr[i-1]; arr[i-1] = arr[index]; arr[index] = temp; } } //显示结果 for(int i=0; i&lt;arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https:///derbo.gitub.io/post/studyday09/" />
<meta property="article:published_time" content="2019-07-27T13:13:37&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-27T13:13:37&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https:///derbo.gitub.io/"><img class="app-header-avatar" src="/derbo.gitub.io/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">数组排序算法   (二)直接排序</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 27, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      

<p>对我以学知识的整理</p>

<h2 id="我的github-https-github-com-derbo">我的GitHub:<a href="https://github.com/DerBo">https://github.com/DerBo</a></h2>

<h2 id="原理-将一个数作为基准-默认选第一个元素-用一个数据类型存储起来-通过将它后面的元素和保存的元素相比较-比它小-大-的和他交换位置-这样进行n-1次的遍历就可排好数组">原理：将一个数作为基准(默认选第一个元素)，用一个数据类型存储起来，通过将它后面的元素和保存的元素相比较，比它小(大)的和他交换位置，这样进行N-1次的遍历就可排好数组。</h2>

<p>一 、代码</p>

<pre><code class="language-java">    int[] arr = {49,38,65,97,76,13,27,49};

        for(int i=1; i&lt;arr.length; i++){//外循环的次数 = 轮数 = 数组的长度-1
        //（1）找出本轮未排序元素中的最值
        /*
        未排序元素：
        第1轮：i=1,未排序，[0,7]
        第2轮：i=2,未排序，[1,7]
        ...
        第7轮：i=7,未排序，[6,7]
    
        每一轮未排序元素的起始下标：0,1,2,3,4,5,6，正好是i-1的
        未排序的后面的元素依次：
        第1轮：[1,7]  j=1,2,3,4,5,6,7
        第2轮：[2,4]  j=2,3,4,5,6,7
        。。。。
        第7轮：[7]    j=7
        j的起点是i，终点都是7
        */
        int max = arr[i-1];
        int index = i-1;
        for(int j=i; j&lt;arr.length; j++){
            if(arr[j] &gt; max){
            max = arr[j];
            index = j;
            }
        }
    
        //（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换
        /*
        第1轮，最大值应该在[0]
        第2轮，最大值应该在[1]
        ....
        第7轮，最大值应该在[6]
        正好是i-1的值
        */
        if(index != i-1){
            //交换arr[i-1]与arr[index]
            int temp = arr[i-1];
            arr[i-1] = arr[index];
            arr[index] = temp;
            }
        }

       //显示结果
       for(int i=0; i&lt;arr.length; i++){
	       System.out.print(arr[i]);
        }
</code></pre>

<p>二 、复杂度</p>

<ul>
<li>对于一个完全反顺序的序列外层for循环每进行一次，内部for循环就要遍历一遍数组，所以对于N个数的数列来说它的时间复杂度是O(N^2);</li>
</ul>

<hr />

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
